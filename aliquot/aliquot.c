#include <stdio.h>

// Σταθερά για τη μέγιστη επιτρεπόμενη τιμή στην ακολουθία (10^15), ως long long.
const long long MAX_VALUE = 1000000000000000LL; 

// Σταθερά για το μέγιστο μέγεθος του πίνακα ιστορικού για ανίχνευση κύκλων.
const int MAX_HISTORY = 4096;

/*
 * Συνάρτηση για τον υπολογισμό του αθροίσματος των γνήσιων διαιρετών ενός αριθμού n.
 * Ως γνήσιοι διαιρέτες ορίζονται όλοι οι διαιρέτες του n εκτός του n.
 */
long long sum_proper_divisors(long long n) {
    // Αν ο αριθμός είναι 1 ή μικρότερος, το άθροισμα των γνήσιων διαιρετών είναι 0.
    if (n <= 1) {
        return 0;
    }

    long long sum = 1; // Ξεκινάμε το άθροισμα με 1, καθώς το 1 είναι γνήσιος διαιρέτης όλων των n > 1.
    long long i;

    // Βελτιστοποιημένη επανάληψη: ελέγχουμε διαιρέτες μέχρι την τετραγωνική ρίζα του n.
    for (i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            sum += i; // Προσθέτουμε τον μικρό διαιρέτη i στο άθροισμα.
            // Ελέγχουμε αν ο i δεν είναι η τετραγωνική ρίζα (π.χ. 4 για το 16).
            if (i * i != n) {
                sum += (n / i); // Προσθέτουμε τον αντίστοιχο μεγάλο διαιρέτη (n / i).
            }
        }
    }
    
    return sum; // Επιστρέφουμε το τελικό άθροισμα.
}

/*
 * Κύρια συνάρτηση για τη δημιουργία και ανάλυση της ακολουθίας Aliquot.
 */
int main() {
    // Βασικές μεταβλητές εισόδου και υπολογισμού.
    long long current_num; // Ο τρέχων αριθμός της ακολουθίας.
    long long max_length;  // Το μέγιστο μήκος της ακολουθίας (0 για απεριόριστο).
    char output_mode;      // Ο τρόπος εκτύπωσης ('f' για πλήρη, 'l' για μήκος).
    long long next_num;    // Ο επόμενος αριθμός της ακολουθίας.
    long long sequence_length = 0; // Μετρητής του μήκους της ακολουθίας (βήματα).
    
    // Πίνακας ιστορικού για την αποθήκευση των αριθμών και την ανίχνευση κύκλων.
    long long history[MAX_HISTORY];
    int history_count = 0; // Ο αριθμός των στοιχείων που έχουν αποθηκευτεί στον πίνακα.
    
    // Σημαίες (flags) για τον δομημένο τερματισμό του βρόχου (0 = false, 1 = true).
    int terminated = 0;     // Γίνεται 1 όταν βρεθεί τερματισμός (π.χ. στο 1) ή κύκλος.
    int limit_exceeded = 0; // Γίνεται 1 αν η τιμή ξεπεράσει το MAX_VALUE.
    int cycle_detected = 0; // Γίνεται 1 αν ο τρέχων αριθμός βρεθεί στο ιστορικό.
    int history_full = 0;   // Γίνεται 1 αν ο πίνακας ιστορικού γεμίσει.
    
    // Μεταβλητές για δεδομένα κύκλου.
    int cycle_start_index = -1; // Η θέση στον πίνακα όπου ξεκινά ο κύκλος.
    int i; // Μεταβλητή επανάληψης (loop counter).
    
    // --- 1. Ανάγνωση και επικύρωση εισόδου ---
    
    printf("Εισάγετε αρχικό αριθμό, μέγιστο μήκος (0 για άπειρο), και τρόπο εκτύπωσης (f/l): ");

    // Προσπαθούμε να διαβάσουμε 3 τιμές. Αν δεν διαβαστούν 3, η είσοδος είναι άκυρη.
    if (scanf("%lld %lld %c", &current_num, &max_length, &output_mode) != 3) {
        fprintf(stderr, "Σφάλμα: Μη έγκυρη μορφή εισόδου.\n");
        return 1; // Κωδικός εξόδου 1 για σφάλμα.
    }
    
    // Επικύρωση: Ο αρχικός αριθμός πρέπει να είναι θετικός.
    if (current_num <= 0) {
        fprintf(stderr, "Σφάλμα: Ο αρχικός αριθμός πρέπει να είναι θετικός ακέραιος.\n");
        return 1;
    }
    
    // Επικύρωση: Ο τρόπος εκτύπωσης πρέπει να είναι 'f' ή 'l'.
    if (output_mode != 'f' && output_mode != 'l') {
        fprintf(stderr, "Σφάλμα: Μη έγκυρος χαρακτήρας τρόπου εκτύπωσης. Χρησιμοποιήστε 'f' (full) ή 'l' (length).\n");
        return 1;
    }
    
    // Έλεγχος ορίου: Ο αρχικός αριθμός δεν πρέπει να υπερβαίνει το MAX_VALUE.
    if (current_num > MAX_VALUE) {
        fprintf(stderr, "Σφάλμα: Ο αρχικός αριθμός %lld υπερβαίνει τη μέγιστη επιτρεπόμενη τιμή των %lld.\n", current_num, MAX_VALUE);
        return 1;
    }

    // --- 2. Βρόχος Δημιουργίας Ακολουθίας ---

    // Ο βρόχος συνεχίζεται μέχρι η σημαία terminated να γίνει 1.
    while (!terminated) {
        sequence_length++; // Αυξάνουμε τον μετρητή μήκους για το τρέχον βήμα.
        
        // --- A. Έλεγχος Συνθήκης Μέγιστου Μήκους ---
        // Αν το max_length δεν είναι 0 (άπειρο) και το μήκος έχει φτάσει το όριο.
        if (max_length != 0 && sequence_length > max_length) {
            if (output_mode == 'f') {
                printf(" (Μέγιστο μήκος %lld επιτεύχθηκε)\n", max_length);
            }
            break; // Έξοδος από τον βρόχο.
        }
        
        // --- B. Εκτύπωση Τρέχοντος Αριθμού ---
        if (output_mode == 'f') {
            printf("%lld", current_num);
        }

        // --- C. Έλεγχος για Κύκλους στο Ιστορικό ---
        // Ελέγχουμε αν ο current_num έχει ξαναεμφανιστεί.
        for (i = 0; i < history_count; i++) {
            if (history[i] == current_num) {
                cycle_start_index = i; // Κρατάμε τη θέση έναρξης του κύκλου.
                cycle_detected = 1;    // Σημαδεύουμε ότι βρέθηκε κύκλος.
                if (output_mode == 'f') {
                    printf(" (Κύκλος εντοπίστηκε, επαναλαμβάνεται %lld)\n", current_num);
                }
                terminated = 1; // Τερματίζουμε τον βρόχο.
                break;
            }
        }
        if (cycle_detected) break; // Αν βρέθηκε κύκλος στον εσωτερικό βρόχο, βγαίνουμε και από τον εξωτερικό.
        
        // --- D. Έλεγχος για Τερματισμό (στο 1) ---
        if (current_num == 1) {
            if (output_mode == 'f') {
                printf(" (Η ακολουθία τερματίζεται στο 1)\n");
            }
            terminated = 1; // Τερματίζουμε τον βρόχο.
            break;
        }

        // --- E. Ενημέρωση Ιστορικού ---
        // Ελέγχουμε αν υπάρχει χώρος στον πίνακα.
        if (history_count < MAX_HISTORY) {
            history[history_count] = current_num; // Αποθηκεύουμε τον τρέχοντα αριθμό.
            history_count++; // Αυξάνουμε τον μετρητή ιστορικού.
        } else {
            history_full = 1; // Σημαδεύουμε ότι γέμισε το ιστορικό.
            if (output_mode == 'f') {
                printf(" -> (Το όριο ιστορικού %d εξαντλήθηκε)\n", MAX_HISTORY);
            }
            break; // Έξοδος από τον βρόχο.
        }

        // --- F. Υπολογισμός Επόμενου Αριθμού ---
        next_num = sum_proper_divisors(current_num);

        // --- G. Έλεγχος Υπέρβασης Ορίου (10^15) ---
        if (next_num > MAX_VALUE) {
            fprintf(stderr, "\nΣφάλμα: Ο αριθμός της ακολουθίας %lld υπερβαίνει τη μέγιστη επιτρεπόμενη τιμή των %lld.\n", next_num, MAX_VALUE);
            limit_exceeded = 1; // Σημαδεύουμε ότι ξεπεράστηκε το όριο.
            break; // Έξοδος από τον βρόχο με σφάλμα.
        }

        // --- H. Έλεγχος για Τέλειο Αριθμό (n -> n) ---
        // Ο τέλειος αριθμός είναι κύκλος μήκους 1.
        if (next_num == current_num) {
             cycle_detected = 1; // Σημαδεύουμε κύκλο.
             cycle_start_index = history_count; // Ο κύκλος ξεκινά από το επόμενο βήμα.
             if (output_mode == 'f') {
                printf(" (Τέλειος αριθμός εντοπίστηκε, επαναλαμβάνεται %lld)\n", current_num);
            }
            terminated = 1; // Τερματίζουμε τον βρόχο.
            break;
        }
        
        // --- I. Προετοιμασία για το Επόμενο Βήμα ---
        if (output_mode == 'f') {
            printf(" -> ");
        }
        current_num = next_num; // Ο επόμενος αριθμός γίνεται ο τρέχων.
    }

    // --- 3. Τελική Έξοδος και Χειρισμός Σφαλμάτων ---

    // Αν ξεπεράστηκε το όριο, επιστρέφουμε κωδικό σφάλματος 1.
    if (limit_exceeded) {
        return 1; 
    }
    
    // Εκτύπωση τελικού αποτελέσματος ανάλογα με τον τρόπο εξόδου.
    if (output_mode == 'l') { // Εκτύπωση μόνο του μήκους.
        if (cycle_detected || current_num == 1) {
            printf("Μήκος: %lld\n", sequence_length);
        } else if (max_length != 0 && sequence_length > max_length) {
            printf("Μήκος: %lld\n", max_length);
        } else if (history_full) {
            // Αν γέμισε το ιστορικό, το τελευταίο βήμα δεν ολοκληρώθηκε, οπότε αφαιρούμε 1.
            printf("Μήκος: %lld\n", sequence_length - 1);
        } else {
             // Περίπτωση όπου το max_length ήταν 0 (άπειρο) και απλά τερματίσαμε λόγω του break.
            printf("Μήκος: %lld\n", sequence_length - 1);
        }
        
    } else { // 'f' mode (Εκτύπωση πλήρους αποτελέσματος).
        if (cycle_detected) {
            // Υπολογισμός μήκους κύκλου (1 για τέλειο, history_count - index για τους άλλους).
            int length = (next_num == current_num) ? 1 : (history_count - cycle_start_index);
            printf("Μήκος Κύκλου: %d\n", length);
            printf("Συνολικό Μήκος: %lld\n", sequence_length);
        } else if (current_num == 1) {
            printf("Η ακολουθία τερματίστηκε στο 1.\n");
            printf("Συνολικό Μήκος: %lld\n", sequence_length);
        } else if (max_length != 0 && sequence_length > max_length) {
            printf("Η ακολουθία σταμάτησε στο μέγιστο μήκος %lld.\n", max_length);
            printf("Συνολικό Μήκος: %lld\n", max_length);
        } else if (history_full) {
            printf("Η ακολουθία σταμάτησε λόγω ορίου ιστορικού.\n");
            printf("Συνολικό Μήκος: %lld\n", sequence_length - 1);
        }
    }
    
    return 0; // Κωδικός εξόδου 0 για επιτυχημένη εκτέλεση.
}